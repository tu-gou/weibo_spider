pattern_string = [
    '暴毙', '奴婢', '母狗', '卧槽', '傻逼', '煞笔',
    '爱国', '真诚', '人民', '服务', '奋斗', '青春', '支持',
    '尼玛', '绑架', '辱华', '卧槽', '我操', '奴婢',
    '狗屁', '去死', '贪污', '政党', '贪婪',
    '社会', '信仰', '红色', '传承', '为人', '幸福', '安居乐业', '征程', '初心',
    '生活', '提高', '安康', '安全', '国际', '舞台',
    '朋友', '家人', '友爱', '团结', '互助', '拥抱',
    '性交', '性爱', '双修', '做爱', '卖淫', '色情', '发骚',
    '黄色', '援交', '慰安', '性感', '床', '酒',
    '健康', '美丽', '爱', '幸福', '勇敢', '大方',
    '可爱', '迷人', '善良', '正直', '健身', '身材', '性感', '才华', '健康',
    '身材', '避孕套', '玩具', '美女', '卖吡', '多人',
    '朋友', '家人', '友爱', '团结', '互助', '拥抱',
    '殴打', '鞭尸', '分尸', '哭', '骂', '砍刀', '烧死',
    '血腥', '尸体', '暴毙', '辣椒', '斧头', '酒',
    '辣椒', '烤肉', '美食', '饱', '幸福', '大蒜',
    '可爱', '迷人', '善良', '哭', '健身', '身材', '性感', '才华', '健康',
    '仇', '魔鬼', '锤子', '滚', '群殴', '自残', '绑架',
    '朋友', '家人', '友爱', '团结', '互助', '拥抱',
    '自杀', '农药', '遗书', '收尸', '绝望', '自死', '朋友',
    '跳海', '跳楼', '安眠药', '再见', '世界', '煤气',
    '健康', '美丽', '爱', '朋友', '美丽', '告别',
    '焦虑', '迷人', '大海', '正直', '健身', '身材', '性感', '才华', '健康',
    '焦虑', '疾病', '自残', '自杀', '煤气', '毒药'
]

'''
   本算法模拟WM多模式匹配算法，首先将模式串按照utf-8的编码格式编码，因为在本算法实现的时候，要求模式串最短要大于3，而模式串集中基本上都是两个字，
   便采用此种方法将其扩展延长，而且同时使用这个编码结果实现对模式串的哈希。
   准备阶段：
   首先，在按照utf-8方式编码存到新列表时，找到最短的模式串长度，按照这个最短长度切割模式串，然后按照取出的双字符，将其编码值求和，作为哈希函数。
   接下来将取出的双字符，计算出第二个字符距离截取后的模式串末位距离，存入shift表中，如果此时为0，那么要将其存入一个字典中，作为哈希表，键为哈希值，
   即双字符编码和值，值为当前双字符，然而求和会有相等的可能，所以值中为列表保存。
   匹配阶段：
   将切分好的正文列表读入，一个一个比较，首先从正文的第模式串长度-1处开始比较，即直接比较模式串长度下的后两位，如果当前双字符不在shift表中，那么
   直接跳跃模式串长，继续重复上一阶段；如果在shift表中存在，按照shift值移动指针，继续比较；如果值为0，那么就比较这个双字符作为末尾、按照模式串长
   度向前找出这个可能匹配的串，然后在哈希表中找到当前双字符对应的值，取出，将从正文取出的串和从哈希表取出的列表进行一一比较，成功直接记录到最终的
   输出列表当中，然后直接跳跃模式串长，继续比较；如果没能匹配成功，则只移动1位。
   
'''


def find_feature(list_text):
    match = []  # 记录匹配成功的词
    encode_pattern = []  # 存储pattern_string的长度大于3的编码词
    min_length = len(pattern_string[0].encode())  # 最短模式串长度
    for key in pattern_string:
        key = key.encode()
        if len(key) < 4:
            continue
        encode_pattern.append(key)
        temp = len(key)
        if temp < min_length:
            min_length = temp  # 遍历每个加入到encode_pattern的词，找出最短的模式串
    num = min_length - 2 + 1  # 默认以两个字符为单位切分，使用其和最短tag长，计算模式串被相邻两个切分的段数
    i = 0
    temp1 = encode_pattern[0][i] + encode_pattern[0][i + 1]  # 计算shift值所用临时变量
    shift = {temp1: (min_length - i - 2)}  # shift:字典，结构为{双字符：第二个字符到切分后的最后一位的长度}
    hash_match = {}  # 作为哈希表，哈希函数即双字符的utf-8编码和值，同一个值存在同一个键中，然后比较
    i += 1  # 计数器，作为当前指针在某个切分后的模式串的位置，从第一个字符到倒数第二个之间移动指针
    for key in encode_pattern:
        while i < num:
            temp1 = key[i] + key[i + 1]
            m = min_length - i - 2
            if temp1 in shift:
                if m < shift[temp1]:
                    shift[temp1] = m  # 如果有同样的双字符，选择离最后距离最短的值，小跳步
            shift[temp1] = m  # 字典中不存在这个双字符就添加
            if m == 0:
                if temp1 not in shift:
                    hash_match[temp1] = key  # 把切分后的模式串的末位双字符所在的模式串单独记录
                else:
                    hash_match.setdefault(temp1, []).append(key)  # 如果当前末尾双字符出现在了模式串的前面，就把这个末尾双字符所在的模式串加入到字典中
            i += 1
        i = 0
    for text in list_text:
        text = text.encode('utf-8')
        i = min_length - 2  # 初始直接从模式串后两位开始比较，前面没有比较的必要，如果后面两位相同在比较前面
        while i < len(text) - 1:  # 比较到输入文本的倒数第二位
            temp1 = text[i] + text[i + 1]  # 取出文本双字符
            if temp1 in shift:
                if shift[temp1] > 0:
                    i += shift[temp1]  # 如果当前双字符以大于零出现在记录中，直接移动shift值，比较当前双字符后面的字符串
                else:
                    length = len(hash_match[temp1])  # 将当前temp1键所对应的值每个都和这个正文比较
                    temp4 = 0
                    while temp4 < length:  # 开始从正文和模式串对齐处按位比较
                        flag = 0
                        j = i - min_length + 2  # j的位置为双字符所在模式串长度的正文的首位，即开始比较整个串和模式串
                        if hash_match[temp1][temp4] == text[j:j + len(hash_match[temp1][temp4])]:
                            if hash_match[temp1][temp4] not in match:
                                match.append(hash_match[temp1][temp4].decode('utf-8'))  # 当前找到了正文和模式串匹配的地方，将其存到match
                            flag = 1
                            break
                        temp4 += 1
                    if flag == 0:
                        i += 1  # 当前如果是shift=0但失配，那么只向后移动1位继续比较
                    else:
                        i += min_length  # 当前匹配成功，向后跳跃模式串长
            else:
                i += min_length  # 如果当前双字符不在记录中，直接跳跃模式串长
    return match
